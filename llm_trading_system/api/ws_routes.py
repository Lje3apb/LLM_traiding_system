"""WebSocket routes for the LLM Trading System.

This module contains WebSocket endpoints for real-time communication.
Extracted from server.py for better modularity.
"""

from __future__ import annotations

import asyncio
import logging
import time

from fastapi import APIRouter, WebSocket, WebSocketDisconnect

from llm_trading_system.api.auth import validate_ws_token
from llm_trading_system.api.services.websocket_security import (
    check_connection_limit,
    check_message_rate_limit,
    check_session_permission,
    register_connection,
    unregister_connection,
    validate_incoming_message,
    validate_origin,
)
from llm_trading_system.engine.live_service import get_session_manager

# Setup logger
logger = logging.getLogger(__name__)

# Create API router
router = APIRouter()


@router.websocket("/ws/live/{session_id}")
async def live_session_websocket(websocket: WebSocket, session_id: str, token: str = "") -> None:
    """WebSocket endpoint for real-time live session updates.

    Security Features:
    - Token-based authentication (query parameter ?token=...)
    - Origin validation (prevents CSRF attacks)
    - Connection limits per user
    - Message rate limiting
    - Permission checks (users can only access their own sessions)
    - Message validation (pydantic schemas)
    - Resource cleanup on disconnect

    Streams:
    - state_update: Current session state (periodically every 2 seconds)
    - trade: New trade executed
    - bar: New bar completed
    - pong: Response to ping messages

    Args:
        websocket: WebSocket connection
        session_id: Trading session ID to monitor
        token: Authentication token (required query parameter)

    Query Parameters:
        token: WebSocket authentication token generated by generate_ws_token()

    Incoming Message Format:
        {
            "type": "ping" | "subscribe" | "unsubscribe",
            "payload": {...}
        }

    Outgoing Message Format:
        {
            "type": "pong" | "state_update" | "trade" | "bar" | "error",
            "payload": {...},
            "message": "error message (for type=error)"
        }

    Security:
        - Requires valid authentication token (expires after 1 hour)
        - Invalid tokens → close with code 4401
        - Invalid origin → close with code 1008
        - Too many connections → close with code 1008
        - No permission → close with code 1008
        - Maximum connection duration: 1 hour
        - Rate limit: 10 messages/second, 100 messages/minute per user
    """
    # ========================================================================
    # Step 1: Validate authentication token BEFORE accepting connection
    # ========================================================================
    user_id = validate_ws_token(token)

    if not user_id:
        session_data = websocket.scope.get("session") or {}
        user_id = session_data.get("user_id")

    if not user_id:
        logger.warning(f"WebSocket auth failed: invalid token for session {session_id}")
        await websocket.close(code=4401, reason="Invalid or expired authentication token")
        return

    # ========================================================================
    # Step 2: Validate Origin header (prevent CSRF attacks)
    # ========================================================================
    if not validate_origin(websocket):
        logger.warning(f"WebSocket rejected: invalid origin for user {user_id}")
        await websocket.close(code=1008, reason="Origin not allowed")
        return

    # ========================================================================
    # Step 3: Check connection limit (prevent resource exhaustion)
    # ========================================================================
    if not check_connection_limit(user_id, websocket):
        logger.warning(f"WebSocket rejected: connection limit for user {user_id}")
        await websocket.close(code=1008, reason="Too many connections")
        return

    # ========================================================================
    # Step 4: Get session manager and check permissions
    # ========================================================================
    manager = get_session_manager()

    # Check if user has permission to access this session
    if not check_session_permission(user_id, session_id, manager):
        logger.warning(f"WebSocket rejected: user {user_id} has no permission for session {session_id}")
        await websocket.close(code=1008, reason="Access denied")
        return

    # ========================================================================
    # Step 5: All checks passed - accept connection
    # ========================================================================
    await websocket.accept()

    # Store user_id in websocket state for later use
    websocket.state.user_id = user_id

    # Register connection for tracking
    register_connection(user_id, websocket)

    # Subscribe to real-time events from the session
    session = manager.get_session(session_id)
    if session:
        session.subscribe(websocket)
        logger.info(f"WebSocket subscribed to session {session_id} for real-time events")

    try:
        # Get initial session status
        try:
            status = manager.get_status(session_id)
        except KeyError:
            await websocket.send_json(
                {"type": "error", "message": f"Session {session_id} not found"}
            )
            await websocket.close()
            return

        # Send initial state
        await websocket.send_json({"type": "state_update", "payload": status})

        # Connection management
        MAX_CONNECTION_TIME = 3600  # 1 hour maximum
        connection_start = time.time()

        # Main message loop
        while True:
            # Check connection age
            connection_age = time.time() - connection_start
            if connection_age > MAX_CONNECTION_TIME:
                await websocket.send_json({
                    "type": "error",
                    "message": "Connection timeout - maximum duration (1 hour) exceeded. Please reconnect."
                })
                break

            # Wait for client messages with timeout
            try:
                raw_message = await asyncio.wait_for(
                    websocket.receive_text(), timeout=2.0
                )

                # ============================================================
                # Rate limiting check for incoming messages
                # ============================================================
                if not check_message_rate_limit(user_id):
                    # Rate limit exceeded - close connection
                    await websocket.send_json({
                        "type": "error",
                        "message": "Rate limit exceeded. Connection closed."
                    })
                    await websocket.close(code=1008, reason="Rate limit exceeded")
                    break

                # ============================================================
                # Validate message structure
                # ============================================================
                message = validate_incoming_message(raw_message)
                if not message:
                    # Invalid message - send error but don't close connection
                    await websocket.send_json({
                        "type": "error",
                        "message": "Invalid message format. Must be JSON with 'type' and optional 'payload'."
                    })
                    continue

                # ============================================================
                # Handle different message types
                # ============================================================
                if message.type == "ping":
                    await websocket.send_json({"type": "pong"})

                elif message.type == "subscribe":
                    # Future: implement subscription management
                    pass

                elif message.type == "unsubscribe":
                    # Future: implement subscription management
                    pass

            except asyncio.TimeoutError:
                # No message from client - send periodic update
                pass

            # ============================================================
            # Send periodic state update
            # ============================================================
            try:
                status = manager.get_status(session_id)
                await websocket.send_json({"type": "state_update", "payload": status})
            except KeyError:
                # Session was deleted
                await websocket.send_json(
                    {"type": "error", "message": f"Session {session_id} was deleted"}
                )
                break
            except Exception as e:
                # Error getting status - log and send sanitized error
                logger.error(f"Error getting session status: {e}", exc_info=True)
                await websocket.send_json(
                    {"type": "error", "message": "Error fetching session status"}
                )

            # Sleep before next update
            await asyncio.sleep(2.0)

    except WebSocketDisconnect:
        # Client disconnected - normal cleanup
        logger.info(f"WebSocket client disconnected: user {user_id}, session {session_id}")

    except Exception as e:
        # Unexpected error - log and send sanitized error
        logger.error(f"WebSocket error: {e}", exc_info=True)
        try:
            await websocket.send_json(
                {"type": "error", "message": "Internal server error"}
            )
        except:
            pass

    finally:
        # ====================================================================
        # Cleanup resources
        # ====================================================================
        # Unsubscribe from session events
        session = manager.get_session(session_id)
        if session:
            session.unsubscribe(websocket)
            logger.info(f"WebSocket unsubscribed from session {session_id}")

        # Unregister connection
        unregister_connection(user_id, websocket)

        # Close connection if still open
        try:
            await websocket.close()
        except:
            pass

        logger.info(f"WebSocket closed: user {user_id}, session {session_id}")
